/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createApplicationFromDiscriminatorValue, createCustomExtensionCallbackConfigurationFromDiscriminatorValue, createDeletedItemContainerFromDiscriminatorValue, createEmailSettingsFromDiscriminatorValue, createGroupFromDiscriminatorValue, createKeyValuePairFromDiscriminatorValue, createSubjectSetFromDiscriminatorValue, createUserFromDiscriminatorValue, deserializeIntoCustomCalloutExtension, deserializeIntoCustomExtensionCallbackConfiguration, deserializeIntoEntity, deserializeIntoSubjectSet, serializeApplication, serializeCustomCalloutExtension, serializeCustomExtensionCallbackConfiguration, serializeDeletedItemContainer, serializeEmailSettings, serializeEntity, serializeGroup, serializeKeyValuePair, serializeSubjectSet, serializeUser, type Application, type CustomCalloutExtension, type CustomExtensionCallbackConfiguration, type DeletedItemContainer, type EmailSettings, type Entity, type Group, type KeyValuePair, type SubjectSet, type User } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AttributeChangeTrigger extends Parsable, WorkflowExecutionTrigger {
    /**
     * The trigger attribute being changed that triggers the workflowexecutiontrigger of a workflow.)
     */
    triggerAttributes?: TriggerAttribute[] | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AttributeChangeTrigger}
 */
// @ts-ignore
export function createAttributeChangeTriggerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAttributeChangeTrigger;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CustomTaskExtensionCallbackConfiguration}
 */
// @ts-ignore
export function createCustomTaskExtensionCallbackConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCustomTaskExtensionCallbackConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CustomTaskExtension}
 */
// @ts-ignore
export function createCustomTaskExtensionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCustomTaskExtension;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GroupBasedSubjectSet}
 */
// @ts-ignore
export function createGroupBasedSubjectSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGroupBasedSubjectSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Insights}
 */
// @ts-ignore
export function createInsightsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoInsights;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LifecycleManagementSettings}
 */
// @ts-ignore
export function createLifecycleManagementSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLifecycleManagementSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LifecycleWorkflowsContainer}
 */
// @ts-ignore
export function createLifecycleWorkflowsContainerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLifecycleWorkflowsContainer;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MembershipChangeTrigger}
 */
// @ts-ignore
export function createMembershipChangeTriggerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMembershipChangeTrigger;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OnDemandExecutionOnly}
 */
// @ts-ignore
export function createOnDemandExecutionOnlyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOnDemandExecutionOnly;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Parameter}
 */
// @ts-ignore
export function createParameterFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoParameter;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RuleBasedSubjectSet}
 */
// @ts-ignore
export function createRuleBasedSubjectSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRuleBasedSubjectSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Run}
 */
// @ts-ignore
export function createRunFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRun;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TaskDefinition}
 */
// @ts-ignore
export function createTaskDefinitionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTaskDefinition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Task}
 */
// @ts-ignore
export function createTaskFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTask;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TaskProcessingResult}
 */
// @ts-ignore
export function createTaskProcessingResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTaskProcessingResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TaskReport}
 */
// @ts-ignore
export function createTaskReportFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTaskReport;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TimeBasedAttributeTrigger}
 */
// @ts-ignore
export function createTimeBasedAttributeTriggerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTimeBasedAttributeTrigger;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TriggerAndScopeBasedConditions}
 */
// @ts-ignore
export function createTriggerAndScopeBasedConditionsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTriggerAndScopeBasedConditions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TriggerAttribute}
 */
// @ts-ignore
export function createTriggerAttributeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTriggerAttribute;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserProcessingResult}
 */
// @ts-ignore
export function createUserProcessingResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserProcessingResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WorkflowBase}
 */
// @ts-ignore
export function createWorkflowBaseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.identityGovernance.workflow":
                    return deserializeIntoWorkflow;
                case "#microsoft.graph.identityGovernance.workflowVersion":
                    return deserializeIntoWorkflowVersion;
            }
        }
    }
    return deserializeIntoWorkflowBase;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WorkflowExecutionConditions}
 */
// @ts-ignore
export function createWorkflowExecutionConditionsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.identityGovernance.onDemandExecutionOnly":
                    return deserializeIntoOnDemandExecutionOnly;
                case "#microsoft.graph.identityGovernance.triggerAndScopeBasedConditions":
                    return deserializeIntoTriggerAndScopeBasedConditions;
            }
        }
    }
    return deserializeIntoWorkflowExecutionConditions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WorkflowExecutionTrigger}
 */
// @ts-ignore
export function createWorkflowExecutionTriggerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.identityGovernance.attributeChangeTrigger":
                    return deserializeIntoAttributeChangeTrigger;
                case "#microsoft.graph.identityGovernance.membershipChangeTrigger":
                    return deserializeIntoMembershipChangeTrigger;
                case "#microsoft.graph.identityGovernance.timeBasedAttributeTrigger":
                    return deserializeIntoTimeBasedAttributeTrigger;
            }
        }
    }
    return deserializeIntoWorkflowExecutionTrigger;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Workflow}
 */
// @ts-ignore
export function createWorkflowFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWorkflow;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WorkflowTemplate}
 */
// @ts-ignore
export function createWorkflowTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWorkflowTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WorkflowVersion}
 */
// @ts-ignore
export function createWorkflowVersionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWorkflowVersion;
}
export interface CustomTaskExtension extends CustomCalloutExtension, Parsable {
    /**
     * The callback configuration for a custom task extension.
     */
    callbackConfiguration?: CustomExtensionCallbackConfiguration | null;
    /**
     * The unique identifier of the Microsoft Entra user that created the custom task extension.Supports $filter(eq, ne) and $expand.
     */
    createdBy?: User | null;
    /**
     * When the custom task extension was created.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    createdDateTime?: Date | null;
    /**
     * The unique identifier of the Microsoft Entra user that modified the custom task extension last.Supports $filter(eq, ne) and $expand.
     */
    lastModifiedBy?: User | null;
    /**
     * When the custom extension was last modified.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    lastModifiedDateTime?: Date | null;
}
export interface CustomTaskExtensionCallbackConfiguration extends CustomExtensionCallbackConfiguration, Parsable {
    /**
     * The authorizedApps property
     */
    authorizedApps?: Application[] | null;
}
/**
 * The deserialization information for the current model
 * @param AttributeChangeTrigger The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAttributeChangeTrigger(attributeChangeTrigger: Partial<AttributeChangeTrigger> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWorkflowExecutionTrigger(attributeChangeTrigger),
        "triggerAttributes": n => { attributeChangeTrigger.triggerAttributes = n.getCollectionOfObjectValues<TriggerAttribute>(createTriggerAttributeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param CustomTaskExtension The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCustomTaskExtension(customTaskExtension: Partial<CustomTaskExtension> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCustomCalloutExtension(customTaskExtension),
        "callbackConfiguration": n => { customTaskExtension.callbackConfiguration = n.getObjectValue<CustomExtensionCallbackConfiguration>(createCustomExtensionCallbackConfigurationFromDiscriminatorValue); },
        "createdBy": n => { customTaskExtension.createdBy = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "createdDateTime": n => { customTaskExtension.createdDateTime = n.getDateValue(); },
        "lastModifiedBy": n => { customTaskExtension.lastModifiedBy = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { customTaskExtension.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param CustomTaskExtensionCallbackConfiguration The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoCustomTaskExtensionCallbackConfiguration(customTaskExtensionCallbackConfiguration: Partial<CustomTaskExtensionCallbackConfiguration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCustomExtensionCallbackConfiguration(customTaskExtensionCallbackConfiguration),
        "authorizedApps": n => { customTaskExtensionCallbackConfiguration.authorizedApps = n.getCollectionOfObjectValues<Application>(createApplicationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param GroupBasedSubjectSet The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGroupBasedSubjectSet(groupBasedSubjectSet: Partial<GroupBasedSubjectSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSubjectSet(groupBasedSubjectSet),
        "groups": n => { groupBasedSubjectSet.groups = n.getCollectionOfObjectValues<Group>(createGroupFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Insights The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoInsights(insights: Partial<Insights> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(insights),
    }
}
/**
 * The deserialization information for the current model
 * @param LifecycleManagementSettings The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLifecycleManagementSettings(lifecycleManagementSettings: Partial<LifecycleManagementSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(lifecycleManagementSettings),
        "emailSettings": n => { lifecycleManagementSettings.emailSettings = n.getObjectValue<EmailSettings>(createEmailSettingsFromDiscriminatorValue); },
        "workflowScheduleIntervalInHours": n => { lifecycleManagementSettings.workflowScheduleIntervalInHours = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param LifecycleWorkflowsContainer The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLifecycleWorkflowsContainer(lifecycleWorkflowsContainer: Partial<LifecycleWorkflowsContainer> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(lifecycleWorkflowsContainer),
        "customTaskExtensions": n => { lifecycleWorkflowsContainer.customTaskExtensions = n.getCollectionOfObjectValues<CustomTaskExtension>(createCustomTaskExtensionFromDiscriminatorValue); },
        "deletedItems": n => { lifecycleWorkflowsContainer.deletedItems = n.getObjectValue<DeletedItemContainer>(createDeletedItemContainerFromDiscriminatorValue); },
        "insights": n => { lifecycleWorkflowsContainer.insights = n.getObjectValue<Insights>(createInsightsFromDiscriminatorValue); },
        "settings": n => { lifecycleWorkflowsContainer.settings = n.getObjectValue<LifecycleManagementSettings>(createLifecycleManagementSettingsFromDiscriminatorValue); },
        "taskDefinitions": n => { lifecycleWorkflowsContainer.taskDefinitions = n.getCollectionOfObjectValues<TaskDefinition>(createTaskDefinitionFromDiscriminatorValue); },
        "workflows": n => { lifecycleWorkflowsContainer.workflows = n.getCollectionOfObjectValues<Workflow>(createWorkflowFromDiscriminatorValue); },
        "workflowTemplates": n => { lifecycleWorkflowsContainer.workflowTemplates = n.getCollectionOfObjectValues<WorkflowTemplate>(createWorkflowTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param MembershipChangeTrigger The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoMembershipChangeTrigger(membershipChangeTrigger: Partial<MembershipChangeTrigger> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWorkflowExecutionTrigger(membershipChangeTrigger),
        "changeType": n => { membershipChangeTrigger.changeType = n.getEnumValue<MembershipChangeType>(MembershipChangeTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param OnDemandExecutionOnly The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoOnDemandExecutionOnly(onDemandExecutionOnly: Partial<OnDemandExecutionOnly> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWorkflowExecutionConditions(onDemandExecutionOnly),
    }
}
/**
 * The deserialization information for the current model
 * @param Parameter The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoParameter(parameter: Partial<Parameter> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "name": n => { parameter.name = n.getStringValue(); },
        "@odata.type": n => { parameter.odataType = n.getStringValue(); },
        "values": n => { parameter.values = n.getCollectionOfPrimitiveValues<string>(); },
        "valueType": n => { parameter.valueType = n.getEnumValue<ValueType>(ValueTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param RuleBasedSubjectSet The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRuleBasedSubjectSet(ruleBasedSubjectSet: Partial<RuleBasedSubjectSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSubjectSet(ruleBasedSubjectSet),
        "rule": n => { ruleBasedSubjectSet.rule = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Run The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRun(run: Partial<Run> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(run),
        "completedDateTime": n => { run.completedDateTime = n.getDateValue(); },
        "failedTasksCount": n => { run.failedTasksCount = n.getNumberValue(); },
        "failedUsersCount": n => { run.failedUsersCount = n.getNumberValue(); },
        "lastUpdatedDateTime": n => { run.lastUpdatedDateTime = n.getDateValue(); },
        "processingStatus": n => { run.processingStatus = n.getEnumValue<LifecycleWorkflowProcessingStatus>(LifecycleWorkflowProcessingStatusObject); },
        "scheduledDateTime": n => { run.scheduledDateTime = n.getDateValue(); },
        "startedDateTime": n => { run.startedDateTime = n.getDateValue(); },
        "successfulUsersCount": n => { run.successfulUsersCount = n.getNumberValue(); },
        "taskProcessingResults": n => { run.taskProcessingResults = n.getCollectionOfObjectValues<TaskProcessingResult>(createTaskProcessingResultFromDiscriminatorValue); },
        "totalTasksCount": n => { run.totalTasksCount = n.getNumberValue(); },
        "totalUnprocessedTasksCount": n => { run.totalUnprocessedTasksCount = n.getNumberValue(); },
        "totalUsersCount": n => { run.totalUsersCount = n.getNumberValue(); },
        "userProcessingResults": n => { run.userProcessingResults = n.getCollectionOfObjectValues<UserProcessingResult>(createUserProcessingResultFromDiscriminatorValue); },
        "workflowExecutionType": n => { run.workflowExecutionType = n.getEnumValue<WorkflowExecutionType>(WorkflowExecutionTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param Task The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTask(task: Partial<Task> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(task),
        "arguments": n => { task.arguments = n.getCollectionOfObjectValues<KeyValuePair>(createKeyValuePairFromDiscriminatorValue); },
        "category": n => { task.category = n.getCollectionOfEnumValues<LifecycleTaskCategory>(LifecycleTaskCategoryObject); },
        "continueOnError": n => { task.continueOnError = n.getBooleanValue(); },
        "description": n => { task.description = n.getStringValue(); },
        "displayName": n => { task.displayName = n.getStringValue(); },
        "executionSequence": n => { task.executionSequence = n.getNumberValue(); },
        "isEnabled": n => { task.isEnabled = n.getBooleanValue(); },
        "taskDefinitionId": n => { task.taskDefinitionId = n.getStringValue(); },
        "taskProcessingResults": n => { task.taskProcessingResults = n.getCollectionOfObjectValues<TaskProcessingResult>(createTaskProcessingResultFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TaskDefinition The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTaskDefinition(taskDefinition: Partial<TaskDefinition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(taskDefinition),
        "category": n => { taskDefinition.category = n.getCollectionOfEnumValues<LifecycleTaskCategory>(LifecycleTaskCategoryObject); },
        "continueOnError": n => { taskDefinition.continueOnError = n.getBooleanValue(); },
        "description": n => { taskDefinition.description = n.getStringValue(); },
        "displayName": n => { taskDefinition.displayName = n.getStringValue(); },
        "parameters": n => { taskDefinition.parameters = n.getCollectionOfObjectValues<Parameter>(createParameterFromDiscriminatorValue); },
        "version": n => { taskDefinition.version = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TaskProcessingResult The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTaskProcessingResult(taskProcessingResult: Partial<TaskProcessingResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(taskProcessingResult),
        "completedDateTime": n => { taskProcessingResult.completedDateTime = n.getDateValue(); },
        "createdDateTime": n => { taskProcessingResult.createdDateTime = n.getDateValue(); },
        "failureReason": n => { taskProcessingResult.failureReason = n.getStringValue(); },
        "processingStatus": n => { taskProcessingResult.processingStatus = n.getEnumValue<LifecycleWorkflowProcessingStatus>(LifecycleWorkflowProcessingStatusObject); },
        "startedDateTime": n => { taskProcessingResult.startedDateTime = n.getDateValue(); },
        "subject": n => { taskProcessingResult.subject = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "task": n => { taskProcessingResult.task = n.getObjectValue<Task>(createTaskFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TaskReport The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTaskReport(taskReport: Partial<TaskReport> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(taskReport),
        "completedDateTime": n => { taskReport.completedDateTime = n.getDateValue(); },
        "failedUsersCount": n => { taskReport.failedUsersCount = n.getNumberValue(); },
        "lastUpdatedDateTime": n => { taskReport.lastUpdatedDateTime = n.getDateValue(); },
        "processingStatus": n => { taskReport.processingStatus = n.getEnumValue<LifecycleWorkflowProcessingStatus>(LifecycleWorkflowProcessingStatusObject); },
        "runId": n => { taskReport.runId = n.getStringValue(); },
        "startedDateTime": n => { taskReport.startedDateTime = n.getDateValue(); },
        "successfulUsersCount": n => { taskReport.successfulUsersCount = n.getNumberValue(); },
        "task": n => { taskReport.task = n.getObjectValue<Task>(createTaskFromDiscriminatorValue); },
        "taskDefinition": n => { taskReport.taskDefinition = n.getObjectValue<TaskDefinition>(createTaskDefinitionFromDiscriminatorValue); },
        "taskProcessingResults": n => { taskReport.taskProcessingResults = n.getCollectionOfObjectValues<TaskProcessingResult>(createTaskProcessingResultFromDiscriminatorValue); },
        "totalUsersCount": n => { taskReport.totalUsersCount = n.getNumberValue(); },
        "unprocessedUsersCount": n => { taskReport.unprocessedUsersCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TimeBasedAttributeTrigger The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTimeBasedAttributeTrigger(timeBasedAttributeTrigger: Partial<TimeBasedAttributeTrigger> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWorkflowExecutionTrigger(timeBasedAttributeTrigger),
        "offsetInDays": n => { timeBasedAttributeTrigger.offsetInDays = n.getNumberValue(); },
        "timeBasedAttribute": n => { timeBasedAttributeTrigger.timeBasedAttribute = n.getEnumValue<WorkflowTriggerTimeBasedAttribute>(WorkflowTriggerTimeBasedAttributeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param TriggerAndScopeBasedConditions The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTriggerAndScopeBasedConditions(triggerAndScopeBasedConditions: Partial<TriggerAndScopeBasedConditions> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWorkflowExecutionConditions(triggerAndScopeBasedConditions),
        "scope": n => { triggerAndScopeBasedConditions.scope = n.getObjectValue<SubjectSet>(createSubjectSetFromDiscriminatorValue); },
        "trigger": n => { triggerAndScopeBasedConditions.trigger = n.getObjectValue<WorkflowExecutionTrigger>(createWorkflowExecutionTriggerFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TriggerAttribute The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTriggerAttribute(triggerAttribute: Partial<TriggerAttribute> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "name": n => { triggerAttribute.name = n.getStringValue(); },
        "@odata.type": n => { triggerAttribute.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UserProcessingResult The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUserProcessingResult(userProcessingResult: Partial<UserProcessingResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(userProcessingResult),
        "completedDateTime": n => { userProcessingResult.completedDateTime = n.getDateValue(); },
        "failedTasksCount": n => { userProcessingResult.failedTasksCount = n.getNumberValue(); },
        "processingStatus": n => { userProcessingResult.processingStatus = n.getEnumValue<LifecycleWorkflowProcessingStatus>(LifecycleWorkflowProcessingStatusObject); },
        "scheduledDateTime": n => { userProcessingResult.scheduledDateTime = n.getDateValue(); },
        "startedDateTime": n => { userProcessingResult.startedDateTime = n.getDateValue(); },
        "subject": n => { userProcessingResult.subject = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "taskProcessingResults": n => { userProcessingResult.taskProcessingResults = n.getCollectionOfObjectValues<TaskProcessingResult>(createTaskProcessingResultFromDiscriminatorValue); },
        "totalTasksCount": n => { userProcessingResult.totalTasksCount = n.getNumberValue(); },
        "totalUnprocessedTasksCount": n => { userProcessingResult.totalUnprocessedTasksCount = n.getNumberValue(); },
        "workflowExecutionType": n => { userProcessingResult.workflowExecutionType = n.getEnumValue<WorkflowExecutionType>(WorkflowExecutionTypeObject); },
        "workflowVersion": n => { userProcessingResult.workflowVersion = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Workflow The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWorkflow(workflow: Partial<Workflow> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWorkflowBase(workflow),
        "deletedDateTime": n => { workflow.deletedDateTime = n.getDateValue(); },
        "executionScope": n => { workflow.executionScope = n.getCollectionOfObjectValues<UserProcessingResult>(createUserProcessingResultFromDiscriminatorValue); },
        "id": n => { workflow.id = n.getStringValue(); },
        "nextScheduleRunDateTime": n => { workflow.nextScheduleRunDateTime = n.getDateValue(); },
        "runs": n => { workflow.runs = n.getCollectionOfObjectValues<Run>(createRunFromDiscriminatorValue); },
        "taskReports": n => { workflow.taskReports = n.getCollectionOfObjectValues<TaskReport>(createTaskReportFromDiscriminatorValue); },
        "userProcessingResults": n => { workflow.userProcessingResults = n.getCollectionOfObjectValues<UserProcessingResult>(createUserProcessingResultFromDiscriminatorValue); },
        "version": n => { workflow.version = n.getNumberValue(); },
        "versions": n => { workflow.versions = n.getCollectionOfObjectValues<WorkflowVersion>(createWorkflowVersionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param WorkflowBase The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWorkflowBase(workflowBase: Partial<WorkflowBase> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "category": n => { workflowBase.category = n.getEnumValue<LifecycleWorkflowCategory>(LifecycleWorkflowCategoryObject); },
        "createdBy": n => { workflowBase.createdBy = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "createdDateTime": n => { workflowBase.createdDateTime = n.getDateValue(); },
        "description": n => { workflowBase.description = n.getStringValue(); },
        "displayName": n => { workflowBase.displayName = n.getStringValue(); },
        "executionConditions": n => { workflowBase.executionConditions = n.getObjectValue<WorkflowExecutionConditions>(createWorkflowExecutionConditionsFromDiscriminatorValue); },
        "isEnabled": n => { workflowBase.isEnabled = n.getBooleanValue(); },
        "isSchedulingEnabled": n => { workflowBase.isSchedulingEnabled = n.getBooleanValue(); },
        "lastModifiedBy": n => { workflowBase.lastModifiedBy = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { workflowBase.lastModifiedDateTime = n.getDateValue(); },
        "@odata.type": n => { workflowBase.odataType = n.getStringValue(); },
        "tasks": n => { workflowBase.tasks = n.getCollectionOfObjectValues<Task>(createTaskFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param WorkflowExecutionConditions The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWorkflowExecutionConditions(workflowExecutionConditions: Partial<WorkflowExecutionConditions> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { workflowExecutionConditions.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param WorkflowExecutionTrigger The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWorkflowExecutionTrigger(workflowExecutionTrigger: Partial<WorkflowExecutionTrigger> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { workflowExecutionTrigger.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param WorkflowTemplate The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWorkflowTemplate(workflowTemplate: Partial<WorkflowTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(workflowTemplate),
        "category": n => { workflowTemplate.category = n.getEnumValue<LifecycleWorkflowCategory>(LifecycleWorkflowCategoryObject); },
        "description": n => { workflowTemplate.description = n.getStringValue(); },
        "displayName": n => { workflowTemplate.displayName = n.getStringValue(); },
        "executionConditions": n => { workflowTemplate.executionConditions = n.getObjectValue<WorkflowExecutionConditions>(createWorkflowExecutionConditionsFromDiscriminatorValue); },
        "tasks": n => { workflowTemplate.tasks = n.getCollectionOfObjectValues<Task>(createTaskFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param WorkflowVersion The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWorkflowVersion(workflowVersion: Partial<WorkflowVersion> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWorkflowBase(workflowVersion),
        "versionNumber": n => { workflowVersion.versionNumber = n.getNumberValue(); },
    }
}
export interface GroupBasedSubjectSet extends Parsable, SubjectSet {
    /**
     * The groups property
     */
    groups?: Group[] | null;
}
export interface Insights extends Entity, Parsable {
}
export interface LifecycleManagementSettings extends Entity, Parsable {
    /**
     * The emailSettings property
     */
    emailSettings?: EmailSettings | null;
    /**
     * The interval in hours at which all workflows running in the tenant should be scheduled for execution. This interval has a minimum value of 1 and a maximum value of 24. The default value is 3 hours.
     */
    workflowScheduleIntervalInHours?: number | null;
}
export type LifecycleTaskCategory = (typeof LifecycleTaskCategoryObject)[keyof typeof LifecycleTaskCategoryObject];
export type LifecycleWorkflowCategory = (typeof LifecycleWorkflowCategoryObject)[keyof typeof LifecycleWorkflowCategoryObject];
export type LifecycleWorkflowProcessingStatus = (typeof LifecycleWorkflowProcessingStatusObject)[keyof typeof LifecycleWorkflowProcessingStatusObject];
export interface LifecycleWorkflowsContainer extends Entity, Parsable {
    /**
     * The customTaskExtension instance.
     */
    customTaskExtensions?: CustomTaskExtension[] | null;
    /**
     * Deleted workflows in your lifecycle workflows instance.
     */
    deletedItems?: DeletedItemContainer | null;
    /**
     * The insight container holding workflow insight summaries for a tenant.
     */
    insights?: Insights | null;
    /**
     * The settings property
     */
    settings?: LifecycleManagementSettings | null;
    /**
     * The definition of tasks within the lifecycle workflows instance.
     */
    taskDefinitions?: TaskDefinition[] | null;
    /**
     * The workflows in the lifecycle workflows instance.
     */
    workflows?: Workflow[] | null;
    /**
     * The workflow templates in the lifecycle workflow instance.
     */
    workflowTemplates?: WorkflowTemplate[] | null;
}
export interface MembershipChangeTrigger extends Parsable, WorkflowExecutionTrigger {
    /**
     * The changeType property
     */
    changeType?: MembershipChangeType | null;
}
export type MembershipChangeType = (typeof MembershipChangeTypeObject)[keyof typeof MembershipChangeTypeObject];
export interface OnDemandExecutionOnly extends Parsable, WorkflowExecutionConditions {
}
export interface Parameter extends AdditionalDataHolder, Parsable {
    /**
     * The name of the parameter.
     */
    name?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The values of the parameter.
     */
    values?: string[] | null;
    /**
     * The valueType property
     */
    valueType?: ValueType | null;
}
export interface RuleBasedSubjectSet extends Parsable, SubjectSet {
    /**
     * The rule for the subject set. Lifecycle Workflows supports a rich set of user properties for configuring the rules using $filter query expressions. For more information, see supported user and query parameters.
     */
    rule?: string | null;
}
export interface Run extends Entity, Parsable {
    /**
     * The date time that the run completed. Value is null if the workflow hasn't completed.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    completedDateTime?: Date | null;
    /**
     * The number of tasks that failed in the run execution.
     */
    failedTasksCount?: number | null;
    /**
     * The number of users that failed in the run execution.
     */
    failedUsersCount?: number | null;
    /**
     * The datetime that the run was last updated.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    lastUpdatedDateTime?: Date | null;
    /**
     * The processingStatus property
     */
    processingStatus?: LifecycleWorkflowProcessingStatus | null;
    /**
     * The date time that the run is scheduled to be executed for a workflow.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    scheduledDateTime?: Date | null;
    /**
     * The date time that the run execution started.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    startedDateTime?: Date | null;
    /**
     * The number of successfully completed users in the run.
     */
    successfulUsersCount?: number | null;
    /**
     * The related taskProcessingResults.
     */
    taskProcessingResults?: TaskProcessingResult[] | null;
    /**
     * The totalTasksCount property
     */
    totalTasksCount?: number | null;
    /**
     * The total number of unprocessed tasks in the run execution.
     */
    totalUnprocessedTasksCount?: number | null;
    /**
     * The total number of users in the workflow execution.
     */
    totalUsersCount?: number | null;
    /**
     * The associated individual user execution.
     */
    userProcessingResults?: UserProcessingResult[] | null;
    /**
     * The workflowExecutionType property
     */
    workflowExecutionType?: WorkflowExecutionType | null;
}
/**
 * Serializes information the current object
 * @param AttributeChangeTrigger The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAttributeChangeTrigger(writer: SerializationWriter, attributeChangeTrigger: Partial<AttributeChangeTrigger> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!attributeChangeTrigger || isSerializingDerivedType) { return; }
    serializeWorkflowExecutionTrigger(writer, attributeChangeTrigger, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<TriggerAttribute>("triggerAttributes", attributeChangeTrigger.triggerAttributes, serializeTriggerAttribute);
}
/**
 * Serializes information the current object
 * @param CustomTaskExtension The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCustomTaskExtension(writer: SerializationWriter, customTaskExtension: Partial<CustomTaskExtension> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!customTaskExtension || isSerializingDerivedType) { return; }
    serializeCustomCalloutExtension(writer, customTaskExtension, isSerializingDerivedType)
    writer.writeObjectValue<CustomExtensionCallbackConfiguration>("callbackConfiguration", customTaskExtension.callbackConfiguration, serializeCustomExtensionCallbackConfiguration);
    writer.writeObjectValue<User>("createdBy", customTaskExtension.createdBy, serializeUser);
    writer.writeDateValue("createdDateTime", customTaskExtension.createdDateTime);
    writer.writeObjectValue<User>("lastModifiedBy", customTaskExtension.lastModifiedBy, serializeUser);
    writer.writeDateValue("lastModifiedDateTime", customTaskExtension.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param CustomTaskExtensionCallbackConfiguration The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeCustomTaskExtensionCallbackConfiguration(writer: SerializationWriter, customTaskExtensionCallbackConfiguration: Partial<CustomTaskExtensionCallbackConfiguration> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!customTaskExtensionCallbackConfiguration || isSerializingDerivedType) { return; }
    serializeCustomExtensionCallbackConfiguration(writer, customTaskExtensionCallbackConfiguration, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Application>("authorizedApps", customTaskExtensionCallbackConfiguration.authorizedApps, serializeApplication);
}
/**
 * Serializes information the current object
 * @param GroupBasedSubjectSet The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGroupBasedSubjectSet(writer: SerializationWriter, groupBasedSubjectSet: Partial<GroupBasedSubjectSet> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!groupBasedSubjectSet || isSerializingDerivedType) { return; }
    serializeSubjectSet(writer, groupBasedSubjectSet, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Group>("groups", groupBasedSubjectSet.groups, serializeGroup);
}
/**
 * Serializes information the current object
 * @param Insights The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeInsights(writer: SerializationWriter, insights: Partial<Insights> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!insights || isSerializingDerivedType) { return; }
    serializeEntity(writer, insights, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param LifecycleManagementSettings The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLifecycleManagementSettings(writer: SerializationWriter, lifecycleManagementSettings: Partial<LifecycleManagementSettings> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!lifecycleManagementSettings || isSerializingDerivedType) { return; }
    serializeEntity(writer, lifecycleManagementSettings, isSerializingDerivedType)
    writer.writeObjectValue<EmailSettings>("emailSettings", lifecycleManagementSettings.emailSettings, serializeEmailSettings);
    writer.writeNumberValue("workflowScheduleIntervalInHours", lifecycleManagementSettings.workflowScheduleIntervalInHours);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param LifecycleWorkflowsContainer The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLifecycleWorkflowsContainer(writer: SerializationWriter, lifecycleWorkflowsContainer: Partial<LifecycleWorkflowsContainer> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!lifecycleWorkflowsContainer || isSerializingDerivedType) { return; }
    serializeEntity(writer, lifecycleWorkflowsContainer, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<CustomTaskExtension>("customTaskExtensions", lifecycleWorkflowsContainer.customTaskExtensions, serializeCustomTaskExtension);
    writer.writeObjectValue<DeletedItemContainer>("deletedItems", lifecycleWorkflowsContainer.deletedItems, serializeDeletedItemContainer);
    writer.writeObjectValue<Insights>("insights", lifecycleWorkflowsContainer.insights, serializeInsights);
    writer.writeObjectValue<LifecycleManagementSettings>("settings", lifecycleWorkflowsContainer.settings, serializeLifecycleManagementSettings);
    writer.writeCollectionOfObjectValues<TaskDefinition>("taskDefinitions", lifecycleWorkflowsContainer.taskDefinitions, serializeTaskDefinition);
    writer.writeCollectionOfObjectValues<Workflow>("workflows", lifecycleWorkflowsContainer.workflows, serializeWorkflow);
    writer.writeCollectionOfObjectValues<WorkflowTemplate>("workflowTemplates", lifecycleWorkflowsContainer.workflowTemplates, serializeWorkflowTemplate);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param MembershipChangeTrigger The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeMembershipChangeTrigger(writer: SerializationWriter, membershipChangeTrigger: Partial<MembershipChangeTrigger> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!membershipChangeTrigger || isSerializingDerivedType) { return; }
    serializeWorkflowExecutionTrigger(writer, membershipChangeTrigger, isSerializingDerivedType)
    writer.writeEnumValue<MembershipChangeType>("changeType", membershipChangeTrigger.changeType);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param OnDemandExecutionOnly The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeOnDemandExecutionOnly(writer: SerializationWriter, onDemandExecutionOnly: Partial<OnDemandExecutionOnly> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!onDemandExecutionOnly || isSerializingDerivedType) { return; }
    serializeWorkflowExecutionConditions(writer, onDemandExecutionOnly, isSerializingDerivedType)
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Parameter The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeParameter(writer: SerializationWriter, parameter: Partial<Parameter> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!parameter || isSerializingDerivedType) { return; }
    writer.writeStringValue("name", parameter.name);
    writer.writeStringValue("@odata.type", parameter.odataType);
    writer.writeCollectionOfPrimitiveValues<string>("values", parameter.values);
    writer.writeEnumValue<ValueType>("valueType", parameter.valueType);
    writer.writeAdditionalData(parameter.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RuleBasedSubjectSet The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRuleBasedSubjectSet(writer: SerializationWriter, ruleBasedSubjectSet: Partial<RuleBasedSubjectSet> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ruleBasedSubjectSet || isSerializingDerivedType) { return; }
    serializeSubjectSet(writer, ruleBasedSubjectSet, isSerializingDerivedType)
    writer.writeStringValue("rule", ruleBasedSubjectSet.rule);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Run The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRun(writer: SerializationWriter, run: Partial<Run> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!run || isSerializingDerivedType) { return; }
    serializeEntity(writer, run, isSerializingDerivedType)
    writer.writeDateValue("completedDateTime", run.completedDateTime);
    writer.writeNumberValue("failedTasksCount", run.failedTasksCount);
    writer.writeNumberValue("failedUsersCount", run.failedUsersCount);
    writer.writeDateValue("lastUpdatedDateTime", run.lastUpdatedDateTime);
    writer.writeEnumValue<LifecycleWorkflowProcessingStatus>("processingStatus", run.processingStatus);
    writer.writeDateValue("scheduledDateTime", run.scheduledDateTime);
    writer.writeDateValue("startedDateTime", run.startedDateTime);
    writer.writeNumberValue("successfulUsersCount", run.successfulUsersCount);
    writer.writeCollectionOfObjectValues<TaskProcessingResult>("taskProcessingResults", run.taskProcessingResults, serializeTaskProcessingResult);
    writer.writeNumberValue("totalTasksCount", run.totalTasksCount);
    writer.writeNumberValue("totalUnprocessedTasksCount", run.totalUnprocessedTasksCount);
    writer.writeNumberValue("totalUsersCount", run.totalUsersCount);
    writer.writeCollectionOfObjectValues<UserProcessingResult>("userProcessingResults", run.userProcessingResults, serializeUserProcessingResult);
    writer.writeEnumValue<WorkflowExecutionType>("workflowExecutionType", run.workflowExecutionType);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Task The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTask(writer: SerializationWriter, task: Partial<Task> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!task || isSerializingDerivedType) { return; }
    serializeEntity(writer, task, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<KeyValuePair>("arguments", task.arguments, serializeKeyValuePair);
    writer.writeEnumValue<LifecycleTaskCategory[]>("category", task.category);
    writer.writeBooleanValue("continueOnError", task.continueOnError);
    writer.writeStringValue("description", task.description);
    writer.writeStringValue("displayName", task.displayName);
    writer.writeNumberValue("executionSequence", task.executionSequence);
    writer.writeBooleanValue("isEnabled", task.isEnabled);
    writer.writeStringValue("taskDefinitionId", task.taskDefinitionId);
    writer.writeCollectionOfObjectValues<TaskProcessingResult>("taskProcessingResults", task.taskProcessingResults, serializeTaskProcessingResult);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TaskDefinition The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTaskDefinition(writer: SerializationWriter, taskDefinition: Partial<TaskDefinition> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!taskDefinition || isSerializingDerivedType) { return; }
    serializeEntity(writer, taskDefinition, isSerializingDerivedType)
    writer.writeEnumValue<LifecycleTaskCategory[]>("category", taskDefinition.category);
    writer.writeBooleanValue("continueOnError", taskDefinition.continueOnError);
    writer.writeStringValue("description", taskDefinition.description);
    writer.writeStringValue("displayName", taskDefinition.displayName);
    writer.writeCollectionOfObjectValues<Parameter>("parameters", taskDefinition.parameters, serializeParameter);
    writer.writeNumberValue("version", taskDefinition.version);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TaskProcessingResult The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTaskProcessingResult(writer: SerializationWriter, taskProcessingResult: Partial<TaskProcessingResult> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!taskProcessingResult || isSerializingDerivedType) { return; }
    serializeEntity(writer, taskProcessingResult, isSerializingDerivedType)
    writer.writeDateValue("completedDateTime", taskProcessingResult.completedDateTime);
    writer.writeDateValue("createdDateTime", taskProcessingResult.createdDateTime);
    writer.writeStringValue("failureReason", taskProcessingResult.failureReason);
    writer.writeEnumValue<LifecycleWorkflowProcessingStatus>("processingStatus", taskProcessingResult.processingStatus);
    writer.writeDateValue("startedDateTime", taskProcessingResult.startedDateTime);
    writer.writeObjectValue<User>("subject", taskProcessingResult.subject, serializeUser);
    writer.writeObjectValue<Task>("task", taskProcessingResult.task, serializeTask);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TaskReport The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTaskReport(writer: SerializationWriter, taskReport: Partial<TaskReport> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!taskReport || isSerializingDerivedType) { return; }
    serializeEntity(writer, taskReport, isSerializingDerivedType)
    writer.writeDateValue("completedDateTime", taskReport.completedDateTime);
    writer.writeNumberValue("failedUsersCount", taskReport.failedUsersCount);
    writer.writeDateValue("lastUpdatedDateTime", taskReport.lastUpdatedDateTime);
    writer.writeEnumValue<LifecycleWorkflowProcessingStatus>("processingStatus", taskReport.processingStatus);
    writer.writeStringValue("runId", taskReport.runId);
    writer.writeDateValue("startedDateTime", taskReport.startedDateTime);
    writer.writeNumberValue("successfulUsersCount", taskReport.successfulUsersCount);
    writer.writeObjectValue<Task>("task", taskReport.task, serializeTask);
    writer.writeObjectValue<TaskDefinition>("taskDefinition", taskReport.taskDefinition, serializeTaskDefinition);
    writer.writeCollectionOfObjectValues<TaskProcessingResult>("taskProcessingResults", taskReport.taskProcessingResults, serializeTaskProcessingResult);
    writer.writeNumberValue("totalUsersCount", taskReport.totalUsersCount);
    writer.writeNumberValue("unprocessedUsersCount", taskReport.unprocessedUsersCount);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TimeBasedAttributeTrigger The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTimeBasedAttributeTrigger(writer: SerializationWriter, timeBasedAttributeTrigger: Partial<TimeBasedAttributeTrigger> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!timeBasedAttributeTrigger || isSerializingDerivedType) { return; }
    serializeWorkflowExecutionTrigger(writer, timeBasedAttributeTrigger, isSerializingDerivedType)
    writer.writeNumberValue("offsetInDays", timeBasedAttributeTrigger.offsetInDays);
    writer.writeEnumValue<WorkflowTriggerTimeBasedAttribute>("timeBasedAttribute", timeBasedAttributeTrigger.timeBasedAttribute);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TriggerAndScopeBasedConditions The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTriggerAndScopeBasedConditions(writer: SerializationWriter, triggerAndScopeBasedConditions: Partial<TriggerAndScopeBasedConditions> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!triggerAndScopeBasedConditions || isSerializingDerivedType) { return; }
    serializeWorkflowExecutionConditions(writer, triggerAndScopeBasedConditions, isSerializingDerivedType)
    writer.writeObjectValue<SubjectSet>("scope", triggerAndScopeBasedConditions.scope, serializeSubjectSet);
    writer.writeObjectValue<WorkflowExecutionTrigger>("trigger", triggerAndScopeBasedConditions.trigger, serializeWorkflowExecutionTrigger);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TriggerAttribute The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTriggerAttribute(writer: SerializationWriter, triggerAttribute: Partial<TriggerAttribute> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!triggerAttribute || isSerializingDerivedType) { return; }
    writer.writeStringValue("name", triggerAttribute.name);
    writer.writeStringValue("@odata.type", triggerAttribute.odataType);
    writer.writeAdditionalData(triggerAttribute.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UserProcessingResult The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUserProcessingResult(writer: SerializationWriter, userProcessingResult: Partial<UserProcessingResult> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!userProcessingResult || isSerializingDerivedType) { return; }
    serializeEntity(writer, userProcessingResult, isSerializingDerivedType)
    writer.writeDateValue("completedDateTime", userProcessingResult.completedDateTime);
    writer.writeNumberValue("failedTasksCount", userProcessingResult.failedTasksCount);
    writer.writeEnumValue<LifecycleWorkflowProcessingStatus>("processingStatus", userProcessingResult.processingStatus);
    writer.writeDateValue("scheduledDateTime", userProcessingResult.scheduledDateTime);
    writer.writeDateValue("startedDateTime", userProcessingResult.startedDateTime);
    writer.writeObjectValue<User>("subject", userProcessingResult.subject, serializeUser);
    writer.writeCollectionOfObjectValues<TaskProcessingResult>("taskProcessingResults", userProcessingResult.taskProcessingResults, serializeTaskProcessingResult);
    writer.writeNumberValue("totalTasksCount", userProcessingResult.totalTasksCount);
    writer.writeNumberValue("totalUnprocessedTasksCount", userProcessingResult.totalUnprocessedTasksCount);
    writer.writeEnumValue<WorkflowExecutionType>("workflowExecutionType", userProcessingResult.workflowExecutionType);
    writer.writeNumberValue("workflowVersion", userProcessingResult.workflowVersion);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Workflow The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWorkflow(writer: SerializationWriter, workflow: Partial<Workflow> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!workflow || isSerializingDerivedType) { return; }
    serializeWorkflowBase(writer, workflow, isSerializingDerivedType)
    writer.writeDateValue("deletedDateTime", workflow.deletedDateTime);
    writer.writeCollectionOfObjectValues<UserProcessingResult>("executionScope", workflow.executionScope, serializeUserProcessingResult);
    writer.writeStringValue("id", workflow.id);
    writer.writeDateValue("nextScheduleRunDateTime", workflow.nextScheduleRunDateTime);
    writer.writeCollectionOfObjectValues<Run>("runs", workflow.runs, serializeRun);
    writer.writeCollectionOfObjectValues<TaskReport>("taskReports", workflow.taskReports, serializeTaskReport);
    writer.writeCollectionOfObjectValues<UserProcessingResult>("userProcessingResults", workflow.userProcessingResults, serializeUserProcessingResult);
    writer.writeNumberValue("version", workflow.version);
    writer.writeCollectionOfObjectValues<WorkflowVersion>("versions", workflow.versions, serializeWorkflowVersion);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WorkflowBase The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWorkflowBase(writer: SerializationWriter, workflowBase: Partial<WorkflowBase> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!workflowBase || isSerializingDerivedType) { return; }
    writer.writeEnumValue<LifecycleWorkflowCategory>("category", workflowBase.category);
    writer.writeObjectValue<User>("createdBy", workflowBase.createdBy, serializeUser);
    writer.writeDateValue("createdDateTime", workflowBase.createdDateTime);
    writer.writeStringValue("description", workflowBase.description);
    writer.writeStringValue("displayName", workflowBase.displayName);
    writer.writeObjectValue<WorkflowExecutionConditions>("executionConditions", workflowBase.executionConditions, serializeWorkflowExecutionConditions);
    writer.writeBooleanValue("isEnabled", workflowBase.isEnabled);
    writer.writeBooleanValue("isSchedulingEnabled", workflowBase.isSchedulingEnabled);
    writer.writeObjectValue<User>("lastModifiedBy", workflowBase.lastModifiedBy, serializeUser);
    writer.writeDateValue("lastModifiedDateTime", workflowBase.lastModifiedDateTime);
    writer.writeStringValue("@odata.type", workflowBase.odataType);
    writer.writeCollectionOfObjectValues<Task>("tasks", workflowBase.tasks, serializeTask);
    writer.writeAdditionalData(workflowBase.additionalData);
    switch (workflowBase.odataType) {
        case "#microsoft.graph.identityGovernance.workflow":
            serializeWorkflow(writer, workflowBase, true);
        break;
        case "#microsoft.graph.identityGovernance.workflowVersion":
            serializeWorkflowVersion(writer, workflowBase, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WorkflowExecutionConditions The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWorkflowExecutionConditions(writer: SerializationWriter, workflowExecutionConditions: Partial<WorkflowExecutionConditions> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!workflowExecutionConditions || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", workflowExecutionConditions.odataType);
    writer.writeAdditionalData(workflowExecutionConditions.additionalData);
    switch (workflowExecutionConditions.odataType) {
        case "#microsoft.graph.identityGovernance.onDemandExecutionOnly":
            serializeOnDemandExecutionOnly(writer, workflowExecutionConditions, true);
        break;
        case "#microsoft.graph.identityGovernance.triggerAndScopeBasedConditions":
            serializeTriggerAndScopeBasedConditions(writer, workflowExecutionConditions, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WorkflowExecutionTrigger The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWorkflowExecutionTrigger(writer: SerializationWriter, workflowExecutionTrigger: Partial<WorkflowExecutionTrigger> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!workflowExecutionTrigger || isSerializingDerivedType) { return; }
    writer.writeStringValue("@odata.type", workflowExecutionTrigger.odataType);
    writer.writeAdditionalData(workflowExecutionTrigger.additionalData);
    switch (workflowExecutionTrigger.odataType) {
        case "#microsoft.graph.identityGovernance.attributeChangeTrigger":
            serializeAttributeChangeTrigger(writer, workflowExecutionTrigger, true);
        break;
        case "#microsoft.graph.identityGovernance.membershipChangeTrigger":
            serializeMembershipChangeTrigger(writer, workflowExecutionTrigger, true);
        break;
        case "#microsoft.graph.identityGovernance.timeBasedAttributeTrigger":
            serializeTimeBasedAttributeTrigger(writer, workflowExecutionTrigger, true);
        break;
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WorkflowTemplate The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWorkflowTemplate(writer: SerializationWriter, workflowTemplate: Partial<WorkflowTemplate> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!workflowTemplate || isSerializingDerivedType) { return; }
    serializeEntity(writer, workflowTemplate, isSerializingDerivedType)
    writer.writeEnumValue<LifecycleWorkflowCategory>("category", workflowTemplate.category);
    writer.writeStringValue("description", workflowTemplate.description);
    writer.writeStringValue("displayName", workflowTemplate.displayName);
    writer.writeObjectValue<WorkflowExecutionConditions>("executionConditions", workflowTemplate.executionConditions, serializeWorkflowExecutionConditions);
    writer.writeCollectionOfObjectValues<Task>("tasks", workflowTemplate.tasks, serializeTask);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WorkflowVersion The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWorkflowVersion(writer: SerializationWriter, workflowVersion: Partial<WorkflowVersion> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!workflowVersion || isSerializingDerivedType) { return; }
    serializeWorkflowBase(writer, workflowVersion, isSerializingDerivedType)
    writer.writeNumberValue("versionNumber", workflowVersion.versionNumber);
}
export interface Task extends Entity, Parsable {
    /**
     * Arguments included within the task.  For guidance to configure this property, see Configure the arguments for built-in Lifecycle Workflow tasks. Required.
     */
    arguments?: KeyValuePair[] | null;
    /**
     * The category property
     */
    category?: LifecycleTaskCategory[] | null;
    /**
     * A Boolean value that specifies whether, if this task fails, the workflow stops, and subsequent tasks aren't run. Optional.
     */
    continueOnError?: boolean | null;
    /**
     * A string that describes the purpose of the task for administrative use. Optional.
     */
    description?: string | null;
    /**
     * A unique string that identifies the task. Required.Supports $filter(eq, ne) and orderBy.
     */
    displayName?: string | null;
    /**
     * An integer that states in what order the task runs in a workflow.Supports $orderby.
     */
    executionSequence?: number | null;
    /**
     * A Boolean value that denotes whether the task is set to run or not. Optional.Supports $filter(eq, ne) and orderBy.
     */
    isEnabled?: boolean | null;
    /**
     * A unique template identifier for the task. For more information about the tasks that Lifecycle Workflows currently supports and their unique identifiers, see Configure the arguments for built-in Lifecycle Workflow tasks. Required.Supports $filter(eq, ne).
     */
    taskDefinitionId?: string | null;
    /**
     * The result of processing the task.
     */
    taskProcessingResults?: TaskProcessingResult[] | null;
}
export interface TaskDefinition extends Entity, Parsable {
    /**
     * The category property
     */
    category?: LifecycleTaskCategory[] | null;
    /**
     * Defines if the workflow will continue if the task has an error.
     */
    continueOnError?: boolean | null;
    /**
     * The description of the taskDefinition.
     */
    description?: string | null;
    /**
     * The display name of the taskDefinition.Supports $filter(eq, ne) and $orderby.
     */
    displayName?: string | null;
    /**
     * The parameters that must be supplied when creating a workflow task object.Supports $filter(any).
     */
    parameters?: Parameter[] | null;
    /**
     * The version number of the taskDefinition. New records are pushed when we add support for new parameters.Supports $filter(ge, gt, le, lt, eq, ne) and $orderby.
     */
    version?: number | null;
}
export interface TaskProcessingResult extends Entity, Parsable {
    /**
     * The date time when taskProcessingResult execution ended. Value is null if task execution is still in progress.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    completedDateTime?: Date | null;
    /**
     * The date time when the taskProcessingResult was created.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    createdDateTime?: Date | null;
    /**
     * Describes why the taskProcessingResult has failed.
     */
    failureReason?: string | null;
    /**
     * The processingStatus property
     */
    processingStatus?: LifecycleWorkflowProcessingStatus | null;
    /**
     * The date time when taskProcessingResult execution started. Value is null if task execution has not yet started.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    startedDateTime?: Date | null;
    /**
     * The subject property
     */
    subject?: User | null;
    /**
     * The task property
     */
    task?: Task | null;
}
export interface TaskReport extends Entity, Parsable {
    /**
     * The date time that the associated run completed. Value is null if the run has not completed.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    completedDateTime?: Date | null;
    /**
     * The number of users in the run execution for which the associated task failed.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    failedUsersCount?: number | null;
    /**
     * The date and time that the task report was last updated.
     */
    lastUpdatedDateTime?: Date | null;
    /**
     * The processingStatus property
     */
    processingStatus?: LifecycleWorkflowProcessingStatus | null;
    /**
     * The unique identifier of the associated run.
     */
    runId?: string | null;
    /**
     * The date time that the associated run started. Value is null if the run has not started.
     */
    startedDateTime?: Date | null;
    /**
     * The number of users in the run execution for which the associated task succeeded.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    successfulUsersCount?: number | null;
    /**
     * The task property
     */
    task?: Task | null;
    /**
     * The taskDefinition property
     */
    taskDefinition?: TaskDefinition | null;
    /**
     * The related lifecycle workflow taskProcessingResults.
     */
    taskProcessingResults?: TaskProcessingResult[] | null;
    /**
     * The total number of users in the run execution for which the associated task was scheduled to execute.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    totalUsersCount?: number | null;
    /**
     * The number of users in the run execution for which the associated task is queued, in progress, or canceled.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    unprocessedUsersCount?: number | null;
}
export interface TimeBasedAttributeTrigger extends Parsable, WorkflowExecutionTrigger {
    /**
     * How many days before or after the time-based attribute specified the workflow should trigger. For example, if the attribute is employeeHireDate and offsetInDays is -1, then the workflow should trigger one day before the employee hire date. The value can range between -180 and 180 days.
     */
    offsetInDays?: number | null;
    /**
     * The timeBasedAttribute property
     */
    timeBasedAttribute?: WorkflowTriggerTimeBasedAttribute | null;
}
export interface TriggerAndScopeBasedConditions extends Parsable, WorkflowExecutionConditions {
    /**
     * Defines who the workflow runs for.
     */
    scope?: SubjectSet | null;
    /**
     * What triggers a workflow to run.
     */
    trigger?: WorkflowExecutionTrigger | null;
}
export interface TriggerAttribute extends AdditionalDataHolder, Parsable {
    /**
     * The name of the trigger attribute that is changed to trigger an attributeChangeTrigger workflow.
     */
    name?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface UserProcessingResult extends Entity, Parsable {
    /**
     * The date time that the workflow execution for a user completed. Value is null if the workflow hasn't completed.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    completedDateTime?: Date | null;
    /**
     * The number of tasks that failed in the workflow execution.
     */
    failedTasksCount?: number | null;
    /**
     * The processingStatus property
     */
    processingStatus?: LifecycleWorkflowProcessingStatus | null;
    /**
     * The date time that the workflow is scheduled to be executed for a user.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    scheduledDateTime?: Date | null;
    /**
     * The date time that the workflow execution started. Value is null if the workflow execution has not started.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    startedDateTime?: Date | null;
    /**
     * The subject property
     */
    subject?: User | null;
    /**
     * The associated individual task execution.
     */
    taskProcessingResults?: TaskProcessingResult[] | null;
    /**
     * The total number of tasks that in the workflow execution.
     */
    totalTasksCount?: number | null;
    /**
     * The total number of unprocessed tasks for the workflow.
     */
    totalUnprocessedTasksCount?: number | null;
    /**
     * The workflowExecutionType property
     */
    workflowExecutionType?: WorkflowExecutionType | null;
    /**
     * The version of the workflow that was executed.
     */
    workflowVersion?: number | null;
}
export type ValueType = (typeof ValueTypeObject)[keyof typeof ValueTypeObject];
export interface Workflow extends Parsable, WorkflowBase {
    /**
     * When the workflow was deleted.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    deletedDateTime?: Date | null;
    /**
     * The unique identifier of the Microsoft Entra identity that last modified the workflow object.
     */
    executionScope?: UserProcessingResult[] | null;
    /**
     * Identifier used for individually addressing a specific workflow.Supports $filter(eq, ne) and $orderby.
     */
    id?: string | null;
    /**
     * The date time when the workflow is expected to run next based on the schedule interval, if there are any users matching the execution conditions. Supports $filter(lt,gt) and $orderby.
     */
    nextScheduleRunDateTime?: Date | null;
    /**
     * Workflow runs.
     */
    runs?: Run[] | null;
    /**
     * Represents the aggregation of task execution data for tasks within a workflow object.
     */
    taskReports?: TaskReport[] | null;
    /**
     * Per-user workflow execution results.
     */
    userProcessingResults?: UserProcessingResult[] | null;
    /**
     * The current version number of the workflow. Value is 1 when the workflow is first created.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    version?: number | null;
    /**
     * The workflow versions that are available.
     */
    versions?: WorkflowVersion[] | null;
}
export interface WorkflowBase extends AdditionalDataHolder, Parsable {
    /**
     * The category property
     */
    category?: LifecycleWorkflowCategory | null;
    /**
     * The user who created the workflow.
     */
    createdBy?: User | null;
    /**
     * When a workflow was created.
     */
    createdDateTime?: Date | null;
    /**
     * A string that describes the purpose of the workflow.
     */
    description?: string | null;
    /**
     * A string to identify the workflow.
     */
    displayName?: string | null;
    /**
     * Defines when and for who the workflow will run.
     */
    executionConditions?: WorkflowExecutionConditions | null;
    /**
     * Whether the workflow is enabled or disabled. If this setting is true, the workflow can be run on demand or on schedule when isSchedulingEnabled is true.
     */
    isEnabled?: boolean | null;
    /**
     * If true, the Lifecycle Workflow engine executes the workflow based on the schedule defined by tenant settings. Can't be true for a disabled workflow (where isEnabled is false).
     */
    isSchedulingEnabled?: boolean | null;
    /**
     * The unique identifier of the Microsoft Entra identity that last modified the workflow.
     */
    lastModifiedBy?: User | null;
    /**
     * When the workflow was last modified.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The tasks in the workflow.
     */
    tasks?: Task[] | null;
}
export interface WorkflowExecutionConditions extends AdditionalDataHolder, Parsable {
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface WorkflowExecutionTrigger extends AdditionalDataHolder, Parsable {
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export type WorkflowExecutionType = (typeof WorkflowExecutionTypeObject)[keyof typeof WorkflowExecutionTypeObject];
export interface WorkflowTemplate extends Entity, Parsable {
    /**
     * The category property
     */
    category?: LifecycleWorkflowCategory | null;
    /**
     * The description of the workflowTemplate.
     */
    description?: string | null;
    /**
     * The display name of the workflowTemplate.Supports $filter(eq, ne) and $orderby.
     */
    displayName?: string | null;
    /**
     * Conditions describing when to execute the workflow and the criteria to identify in-scope subject set.
     */
    executionConditions?: WorkflowExecutionConditions | null;
    /**
     * Represents the configured tasks to execute and their execution sequence within a workflow. This relationship is expanded by default.
     */
    tasks?: Task[] | null;
}
export type WorkflowTriggerTimeBasedAttribute = (typeof WorkflowTriggerTimeBasedAttributeObject)[keyof typeof WorkflowTriggerTimeBasedAttributeObject];
export interface WorkflowVersion extends Parsable, WorkflowBase {
    /**
     * The version of the workflow.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    versionNumber?: number | null;
}
export const LifecycleTaskCategoryObject = {
    Joiner: "joiner",
    Leaver: "leaver",
    UnknownFutureValue: "unknownFutureValue",
    Mover: "mover",
} as const;
export const LifecycleWorkflowCategoryObject = {
    Joiner: "joiner",
    Leaver: "leaver",
    UnknownFutureValue: "unknownFutureValue",
    Mover: "mover",
} as const;
export const LifecycleWorkflowProcessingStatusObject = {
    Queued: "queued",
    InProgress: "inProgress",
    Completed: "completed",
    CompletedWithErrors: "completedWithErrors",
    Canceled: "canceled",
    Failed: "failed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MembershipChangeTypeObject = {
    Add: "add",
    Remove: "remove",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ValueTypeObject = {
    EnumEscaped: "enum",
    String: "string",
    Int: "int",
    Bool: "bool",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const WorkflowExecutionTypeObject = {
    Scheduled: "scheduled",
    OnDemand: "onDemand",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const WorkflowTriggerTimeBasedAttributeObject = {
    EmployeeHireDate: "employeeHireDate",
    EmployeeLeaveDateTime: "employeeLeaveDateTime",
    UnknownFutureValue: "unknownFutureValue",
    CreatedDateTime: "createdDateTime",
} as const;
/* tslint:enable */
/* eslint-enable */
